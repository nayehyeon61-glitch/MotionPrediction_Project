https://imagej.net/imagej-wiki-static/Skeletonize3D



PxReal dist = PxGeometryQuery::pointDistance(point, geom, pose, closestPoint);




static const PxVec3 convexVerts[] = {PxVec3(0,1,0),PxVec3(1,0,0),PxVec3(-1,0,0),PxVec3(0,0,1),
    PxVec3(0,0,-1)};
PxConvexMeshDesc convexDesc;
convexDesc.points.count     = 5;
convexDesc.points.stride    = sizeof(PxVec3);
convexDesc.points.data      = convexVerts;
convexDesc.flags            = PxConvexFlag::eCOMPUTE_CONVEX;


PxDefaultMemoryOutputStream buf;
PxConvexMeshCookingResult::Enum result;
if(!cooking.cookConvexMesh(convexDesc, buf, &result))
    return NULL;
PxDefaultMemoryInputData input(buf.getData(), buf.getSize());
PxConvexMesh* convexMesh = physics->createConvexMesh(input);



PxShape* aConvexShape = PxRigidActorExt::createExclusiveShape(*aConvexActor,
    PxConvexMeshGeometry(convexMesh), aMaterial);

= weight painting =

for each vertex in the mesh

measure distance to convexes

find argMin.

find four neighbors

measure min distances

idw.




= balancing tree =

// Convenience function for creating an array from BST in-order traversal
vector<int> createArrayFromTree(Node *root, vector<int> arr = vector<int>()) {
    if(root == nullptr) return arr;
    arr = createArrayFromTree(root->left, arr);
    arr.push_back(root->key);
    arr = createArrayFromTree(root->right, arr);
    return arr;
}



#include <bits/stdc++.h>

using namespace std;

class Node {
  public:
    Node * left; //a pointer to the root of the left subtree
    Node * right; //a pointer to the root of the right subtree
    int key;

    Node(int key) : key(key) { }
};

// build returns a pointer to the root Node of the sub-tree
// lower is the lower index of the array
// upper is the upper index of the array
Node * build(const vector<int> &arr, int lower, int upper) {
  int size = upper - lower + 1;
  // cout << size; //uncomment in case you want to see how it's working
  // base case: array of size zero
  if (size <= 0)
    return NULL;
  // recursive case
  int middle = size / 2 + lower;
  // make sure you add the offset of lower
  //  cout << arr[middle] << " "; //uncomment in case you want to see how it's working
  Node * subtreeRoot = new Node(arr[middle]);
  subtreeRoot -> left = build(arr, lower, middle - 1);
  subtreeRoot -> right = build(arr, middle + 1, upper);
  return subtreeRoot;
}

// For convenience, In-order printing a tree
void printTree(Node *root) {
    if(root == nullptr) return;
    printTree(root->left);
    cout << root->key << " ";
    printTree(root->right);
}

// For convenience, we create a right skewed BST.
// This BST will later be balanced.
Node* buildBSTfromSortedArr(int* arr, int n) {
    if(n == 0) return nullptr;
    Node *root = new Node(arr[0]);

    Node *cur = root;
    for(int i = 1; i<n; i++) {
        cur->right = new Node(arr[i]);
        cur = cur->right;
    }
    return root;
}

// Convenience function for creating an array from BST in-order traversal
vector<int> createArrayFromTree(Node *root, vector<int> arr = vector<int>()) {
    if(root == nullptr) return arr;
    arr = createArrayFromTree(root->left, arr);
    arr.push_back(root->key);
    arr = createArrayFromTree(root->right, arr);
    return arr;
}

int main() {
    int arr[] = {10, 11, 17, 19, 30, 31, 37, 38};
    int n = 8;
    // Build a right skewed tree
    Node* root = buildBSTfromSortedArr(arr, n);
    // Get the array from the tree
    vector<int> newArr = createArrayFromTree(root);
    // Make the skewed tree balanced
    Node* newRoot = build(newArr, 0, n-1);
    // In-order printing to verify
    printTree(newRoot);
    return 0;
}



https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.minimum_spanning_tree.html
